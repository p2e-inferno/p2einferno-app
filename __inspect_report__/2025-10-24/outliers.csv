total_exec_time,prop_exec_time,ncalls,sync_io_time,query
00:00:00.269884,23.5%,4,00:00:00,"(
with foreign_keys as (
    select
        cl.relnamespace::regnamespace::text as schema_name,
        cl.relname as table_name,
        cl.oid as table_oid,
        ct.conname as fkey_name,
        ct.conkey as col_attnums
    from
        pg_catalog.pg_constraint ct
        join pg_catalog.pg_class cl -- fkey owning table
            on ct.conrelid = cl.oid
        left join pg_catalog.pg_depend d
            on d.objid = cl.oid
            and d.deptype = $1
    where
        ct.contype = $2 -- foreign key constraints
        and d.objid is null -- exclude tables that are dependencies of extensions
        and cl.relnamespace::regnamespace::text not in (
            $3, $4, $5, $6, $7, $8
        )
),
index_ as (
    select
        pi.indrelid as table_oid,
        indexrelid::regclass as index_,
        string_to_array(indkey::text, $9)::smallint[] as col_attnums
    from
        pg_catalog.pg_index pi
    where
        indisvalid
)
select
    $10 as name,
    $11 as title,
    $12 as level,
    $13 as facing,
    array[$14] as categories,
    $15 as description,
    format(
        $16,
        fk.schema_name,
        fk.table_name,
        fk.fkey_name
    ) as detail,
    $17 as remediation,
    jsonb_build_object(
        $18, fk.schema_name,
        $19, fk.table_name,
        $20, $21,
        $22, fk.fkey_name,
        $23, fk.col_attnums
    ) as metadata,
    format($24, fk.schema_name, fk.table_name, fk.fkey_name) as cache_key
from
    foreign_keys fk
    left join index_ idx
        on fk.table_oid = idx.table_oid
        and fk.col_attnums = idx.col_attnums
    left join pg_catalog.pg_depend dep
        on idx.table_oid = dep.objid
        and dep.deptype = $25
where
    idx.index_ is null
    and fk.schema_name not in (
        $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $40, $41, $42, $43, $44, $45, $46, $47, $48, $49, $50, $51
    )
    and dep.objid is null -- exclude tables owned by extensions
order by
    fk.schema_name,
    fk.table_name,
    fk.fkey_name)
union all
(
select
    $52 as name,
    $53 as title,
    $54 as level,
    $55 as facing,
    array[$56] as categories,
    $57 as description,
    format(
        $58,
        c.relname
    ) as detail,
    $59 as remediation,
    jsonb_build_object(
        $60, n.nspname,
        $61, c.relname,
        $62, $63,
        $64, array_remove(array_agg(DISTINCT case when pg_catalog.has_table_privilege($65, c.oid, $66) then $67 when pg_catalog.has_table_privilege($68, c.oid, $69) then $70 end), $71)
    ) as metadata,
    format($72, n.nspname, c.relname) as cache_key
from
    -- Identify the oid for auth.users
    pg_catalog.pg_class auth_users_pg_class
    join pg_catalog.pg_namespace auth_users_pg_namespace
        on auth_users_pg_class.relnamespace = auth_users_pg_namespace.oid
        and auth_users_pg_class.relname = $73
        and auth_users_pg_namespace.nspname = $74
    -- Depends on auth.users
    join pg_catalog.pg_depend d
        on d.refobjid = auth_users_pg_class.oid
    join pg_catalog.pg_rewrite r
        on r.oid = d.objid
    join pg_catalog.pg_class c
        on c.oid = r.ev_class
    join pg_catalog.pg_namespace n
        on n.oid = c.relnamespace
    join pg_catalog.pg_class pg_class_auth_users
        on d.refobjid = pg_class_auth_users.oid
where
    d.deptype = $75
    and (
      pg_catalog.has_table_privilege($76, c.oid, $77)
      or pg_catalog.has_table_privilege($78, c.oid, $79)
    )
    and n.nspname = any(array(select trim(unnest(string_to_array(current_setting($80, $81), $82)))))
    -- Exclude self
    and c.relname <> $83
    -- There are 3 insecure configurations
    and
    (
        -- Materialized views don't support RLS so this is insecure by default
        (c.relkind in ($84)) -- m for materialized view
        or
        -- Standard View, accessible to anon or authenticated that is security_definer
        (
            c.relkind = $85 -- v for view
            -- Exclude security invoker views
            and not (
                lower(coalesce(c.reloptions::text,$86))::text[]
                && array[
                    $87,
                    $88,
                    $89,
                    $90
                ]
            )
        )
        or
        -- Standard View, security invoker, but no RLS enabled on auth.users
        (
            c.relkind in ($91) -- v for view
            -- is security invoker
            and (
                lower(coalesce(c.reloptions::text,$92))::text[]
                && array[
                    $93,
                    $94,
                    $95,
                    $96
                ]
            )
            and not pg_class_auth_users.relrowsecurity
        )
    )
group by
    n.nspname,
    c.relname,
    c.oid)
union all
(
with policies as (
    select
        nsp.nspname as schema_name,
        pb.tablename as table_name,
        pc.relrowsecurity as is_rls_active,
        polname as policy_name,
        polpermissive as is_permissive, -- if not, then restrictive
        (select array_agg(r::regrole) from unnest(polroles) as x(r)) as roles,
        case polcmd
            when $97 then $98
            when $99 then $100
            when $101 then $102
            when $103 then $104
            when $105 then $106
        end as command,
        qual,
        with_check
    from
        pg_catalog.pg_policy pa
        join pg_catalog.pg_class pc
            on pa.polrelid = pc.oid
        join pg_catalog.pg_namespace nsp
            on pc.relnamespace = nsp.oid
        join pg_catalog.pg_policies pb
            on pc.relname = pb.tablename
            and nsp.nspname = pb.schemaname
            and pa.polname = pb.policyname
)
select
    $107 as name,
    $108 as title,
    $109 as level,
    $110 as facing,
    array[$111] as categories,
    $112 as description,
    format(
        $113,
        schema_name,
        table_name,
        policy_name
    ) as detail,
    $114 as remediation,
    jsonb_build_object(
        $115, schema_name,
        $116, table_name,
        $117, $118
    ) as metadata,
    format($119, schema_name, table_name, policy_name) as cache_key
from
    policies
where
    is_rls_active
    -- NOTE: does not include realtime in support of monitoring policies on realtime.messages
    and schema_name not in (
        $120, $121, $122, $123, $124, $125, $126, $127, $128, $129, $130, $131, $132, $133, $134, $135, $136, $137, $138, $139, $140, $141, $142, $143, $144
    )
    and (
        -- Example: auth.uid()
        (
            qual like $145
            and lower(qual) not like $146
        )
        or (
            qual like $147
            and lower(qual) not like $148
        )
        or (
            qual like $149
            and lower(qual) not like $150
        )
        or (
            qual like $151
            and lower(qual) not like $152
        )
        or (
            with_check like $153
            and lower(with_check) not like $154
        )
        or (
            with_check like $155
            and lower(with_check) not like $156
        )
        or (
            with_check like $157
            and lower(with_check) not like $158
        )
        or (
            with_check like $159
            and lower(with_check) not like $160
        )
    ))
union all
(
select
    $161 as name,
    $162 as title,
    $163 as level,
    $164 as facing,
    array[$165] as categories,
    $166 as description,
    format(
        $167,
        pgns.nspname,
        pgc.relname
    ) as detail,
    $168 as remediation,
     jsonb_build_object(
        $169, pgns.nspname,
        $170, pgc.relname,
        $171, $172
    ) as metadata,
    format(
        $173,
        pgns.nspname,
        pgc.relname
    ) as cache_key
from
    pg_catalog.pg_class pgc
    join pg_catalog.pg_namespace pgns
        on pgns.oid = pgc.relnamespace
    left join pg_catalog.pg_index pgi
        on pgi.indrelid = pgc.oid
    left join pg_catalog.pg_depend dep
        on pgc.oid = dep.objid
        and dep.deptype = $174
where
    pgc.relkind = $175 -- regular tables
    and pgns.nspname not in (
        $176, $177, $178, $179, $180, $181, $182, $183, $184, $185, $186, $187, $188, $189, $190, $191, $192, $193, $194, $195, $196, $197, $198, $199, $200, $201
    )
    and dep.objid is null -- exclude tables owned by extensions
group by
    pgc.oid,
    pgns.nspname,
    pgc.relname
having
    max(coalesce(pgi.indisprimary, $202)::int) = $203)
union all
(
select
    $204 as name,
    $205 as title,
    $206 as level,
    $207 as facing,
    array[$208] as categories,
    $209 as description,
    format(
        $210,
        psui.indexrelname,
        psui.schemaname,
        psui.relname
    ) as detail,
    $211 as remediation,
    jsonb_build_object(
        $212, psui.schemaname,
        $213, psui.relname,
        $214, $215
    ) as metadata,
    format(
        $216,
        psui.schemaname,
        psui.relname,
        psui.indexrelname
    ) as cache_key

from
    pg_catalog.pg_stat_user_indexes psui
    join pg_catalog.pg_index pi
        on psui.indexrelid = pi.indexrelid
    left join pg_catalog.pg_depend dep
        on psui.relid = dep.objid
        and dep.deptype = $217
where
    psui.idx_scan = $218
    and not pi.indisunique
    and not pi.indisprimary
    and dep.objid is null -- exclude tables owned by extensions
    and psui.schemaname not in (
        $219, $220, $221, $222, $223, $224, $225, $226, $227, $228, $229, $230, $231, $232, $233, $234, $235, $236, $237, $238, $239, $240, $241, $242, $243, $244
    ))
union all
(
select
    $245 as name,
    $246 as title,
    $247 as level,
    $248 as facing,
    array[$249] as categories,
    $250 as description,
    format(
        $251,
        n.nspname,
        c.relname,
        r.rolname,
        act.cmd,
        array_agg(p.polname order by p.polname)
    ) as detail,
    $252 as remediation,
    jsonb_build_object(
        $253, n.nspname,
        $254, c.relname,
        $255, $256
    ) as metadata,
    format(
        $257,
        n.nspname,
        c.relname,
        r.rolname,
        act.cmd
    ) as cache_key
from
    pg_catalog.pg_policy p
    join pg_catalog.pg_class c
        on p.polrelid = c.oid
    join pg_catalog.pg_namespace n
        on c.relnamespace = n.oid
    join pg_catalog.pg_roles r
        on p.polroles @> array[r.oid]
        or p.polroles = array[$258::oid]
    left join pg_catalog.pg_depend dep
        on c.oid = dep.objid
        and dep.deptype = $259,
    lateral (
        select x.cmd
        from unnest((
            select
                case p.polcmd
                    when $260 then array[$261]
                    when $262 then array[$263]
                    when $264 then array[$265]
                    when $266 then array[$267]
                    when $268 then array[$269, $270, $271, $272]
                    else array[$273]
                end as actions
        )) x(cmd)
    ) act(cmd)
where
    c.relkind = $274 -- regular tables
    and p.polpermissive -- policy is permissive
    and n.nspname not in (
        $275, $276, $277, $278, $279, $280, $281, $282, $283, $284, $285, $286, $287, $288, $289, $290, $291, $292, $293, $294, $295, $296, $297, $298, $299, $300
    )
    and r.rolname not like $301
    and r.rolname not like $302
    and not r.rolbypassrls
    and dep.objid is null -- exclude tables owned by extensions
group by
    n.nspname,
    c.relname,
    r.rolname,
    act.cmd
having
    count($303) > $304)
union all
(
select
    $305 as name,
    $306 as title,
    $307 as level,
    $308 as facing,
    array[$309] as categories,
    $310 as description,
    format(
        $311,
        n.nspname,
        c.relname,
        array_agg(p.polname order by p.polname)
    ) as detail,
    $312 as remediation,
    jsonb_build_object(
        $313, n.nspname,
        $314, c.relname,
        $315, $316
    ) as metadata,
    format(
        $317,
        n.nspname,
        c.relname
    ) as cache_key
from
    pg_catalog.pg_policy p
    join pg_catalog.pg_class c
        on p.polrelid = c.oid
    join pg_catalog.pg_namespace n
        on c.relnamespace = n.oid
    left join pg_catalog.pg_depend dep
        on c.oid = dep.objid
        and dep.deptype = $318
where
    c.relkind = $319 -- regular tables
    and n.nspname not in (
        $320, $321, $322, $323, $324, $325, $326, $327, $328, $329, $330, $331, $332, $333, $334, $335, $336, $337, $338, $339, $340, $341, $342, $343, $344, $345
    )
    -- RLS is disabled
    and not c.relrowsecurity
    and dep.objid is null -- exclude tables owned by extensions
group by
    n.nspname,
    c.relname)
union all
(
select
    $346 as name,
    $347 as title,
    $348 as level,
    $349 as facing,
    array[$350] as categories,
    $351 as description,
    format(
        $352,
        n.nspname,
        c.relname
    ) as detail,
    $353 as remediation,
    jsonb_build_object(
        $354, n.nspname,
        $355, c.relname,
        $356, $357
    ) as metadata,
    format(
        $358,
        n.nspname,
        c.relname
    ) as cache_key
from
    pg_catalog.pg_class c
    left join pg_catalog.pg_policy p
        on p.polrelid = c.oid
    join pg_catalog.pg_namespace n
        on c.relnamespace = n.oid
    left join pg_catalog.pg_depend dep
        on c.oid = dep.objid
        and dep.deptype = $359
where
    c.relkind = $360 -- regular tables
    and n.nspname not in (
        $361, $362, $363, $364, $365, $366, $367, $368, $369, $370, $371, $372, $373, $374, $375, $376, $377, $378, $379, $380, $381, $382, $383, $384, $385, $386
    )
    -- RLS is enabled
    and c.relrowsecurity
    and p.polname is null
    and dep.objid is null -- exclude tables owned by extensions
group by
    n.nspname,
    c.relname)
union all
(
select
    $387 as name,
    $388 as title,
    $389 as level,
    $390 as facing,
    array[$391] as categories,
    $392 as description,
    format(
        $393,
        n.nspname,
        c.relname,
        array_agg(pi.indexname order by pi.indexname)
    ) as detail,
    $394 as remediation,
    jsonb_build_object(
        $395, n.nspname,
        $396, c.relname,
        $397, case
            when c.relkind = $398 then $399
            when c.relkind = $400 then $401
            else $402
        end,
        $403, array_agg(pi.indexname order by pi.indexname)
    ) as metadata,
    format(
        $404,
        n.nspname,
        c.relname,
        array_agg(pi.indexname order by pi.indexname)
    ) as cache_key
from
    pg_catalog.pg_indexes pi
    join pg_catalog.pg_namespace n
        on n.nspname  = pi.schemaname
    join pg_catalog.pg_class c
        on pi.tablename = c.relname
        and n.oid = c.relnamespace
    left join pg_catalog.pg_depend dep
        on c.oid = dep.objid
        and dep.deptype = $405
where
    c.relkind in ($406, $407) -- tables and materialized views
    and n.nspname not in (
        $408, $409, $410, $411, $412, $413, $414, $415, $416, $417, $418, $419, $420, $421, $422, $423, $424, $425, $426, $427, $428, $429, $430, $431, $432, $433
    )
    and dep.objid is null -- exclude tables owned by extensions
group by
    n.nspname,
    c.relkind,
    c.relname,
    replace(pi.indexdef, pi.indexname, $434)
having
    count(*) > $435)
union all
(
select
    $436 as name,
    $437 as title,
    $438 as level,
    $439 as facing,
    array[$440] as categories,
    $441 as description,
    format(
        $442,
        n.nspname,
        c.relname
    ) as detail,
    $443 as remediation,
    jsonb_build_object(
        $444, n.nspname,
        $445, c.relname,
        $446, $447
    ) as metadata,
    format(
        $448,
        n.nspname,
        c.relname
    ) as cache_key
from
    pg_catalog.pg_class c
    join pg_catalog.pg_namespace n
        on n.oid = c.relnamespace
    left join pg_catalog.pg_depend dep
        on c.oid = dep.objid
        and dep.deptype = $449
where
    c.relkind = $450
    and (
        pg_catalog.has_table_privilege($451, c.oid, $452)
        or pg_catalog.has_table_privilege($453, c.oid, $454)
    )
    and substring(pg_catalog.version() from $455) >= $456 -- security invoker was added in pg15
    and n.nspname = any(array(select trim(unnest(string_to_array(current_setting($457, $458), $459)))))
    and n.nspname not in (
        $460, $461, $462, $463, $464, $465, $466, $467, $468, $469, $470, $471, $472, $473, $474, $475, $476, $477, $478, $479, $480, $481, $482, $483, $484, $485
    )
    and dep.objid is null -- exclude views owned by extensions
    and not (
        lower(coalesce(c.reloptions::text,$486))::text[]
        && array[
            $487,
            $488,
            $489,
            $490
        ]
    ))
union all
(
select
    $491 as name,
    $492 as title,
    $493 as level,
    $494 as facing,
    array[$495] as categories,
    $496 as description,
    format(
        $497,
        n.nspname,
        p.proname
    ) as detail,
    $498 as remediation,
    jsonb_build_object(
        $499, n.nspname,
        $500, p.proname,
        $501, $502
    ) as metadata,
    format(
        $503,
        n.nspname,
        p.proname,
        md5(p.prosrc) -- required when function is polymorphic
    ) as cache_key
from
    pg_catalog.pg_proc p
    join pg_catalog.pg_namespace n
        on p.pronamespace = n.oid
    left join pg_catalog.pg_depend dep
        on p.oid = dep.objid
        and dep.deptype = $504
where
    n.nspname not in (
        $505, $506, $507, $508, $509, $510, $511, $512, $513, $514, $515, $516, $517, $518, $519, $520, $521, $522, $523, $524, $525, $526, $527, $528, $529, $530
    )
    and dep.objid is null -- exclude functions owned by extensions
    -- Search path not set to ''
    and not coalesce(p.proconfig, $531) && array[$532])
union all
(
select
    $533 as name,
    $534 as title,
    $535 as level,
    $536 as facing,
    array[$537] as categories,
    $538 as description,
    format(
        $539,
        n.nspname,
        c.relname
    ) as detail,
    $540 as remediation,
    jsonb_build_object(
        $541, n.nspname,
        $542, c.relname,
        $543, $544
    ) as metadata,
    format(
        $545,
        n.nspname,
        c.relname
    ) as cache_key
from
    pg_catalog.pg_class c
    join pg_catalog.pg_namespace n
        on c.relnamespace = n.oid
where
    c.relkind = $546 -- regular tables
    -- RLS is disabled
    and not c.relrowsecurity
    and (
        pg_catalog.has_table_privilege($547, c.oid, $548)
        or pg_catalog.has_table_privilege($549, c.oid, $550)
    )
    and n.nspname = any(array(select trim(unnest(string_to_array(current_setting($551, $552), $553)))))
    and n.nspname not in (
        $554, $555, $556, $557, $558, $559, $560, $561, $562, $563, $564, $565, $566, $567, $568, $569, $570, $571, $572, $573, $574, $575, $576, $577, $578, $579
    ))
union all
(
select
    $580 as name,
    $581 as title,
    $582 as level,
    $583 as facing,
    array[$584] as categories,
    $585 as description,
    format(
        $586,
        pe.extname
    ) as detail,
    $587 as remediation,
    jsonb_build_object(
        $588, pe.extnamespace::regnamespace,
        $589, pe.extname,
        $590, $591
    ) as metadata,
    format(
        $592,
        pe.extname
    ) as cache_key
from
    pg_catalog.pg_extension pe
where
    -- plpgsql is installed by default in public and outside user control
    -- confirmed safe
    pe.extname not in ($593)
    -- Scoping this to public is not optimal. Ideally we would use the postgres
    -- search path. That currently isn't available via SQL. In other lints
    -- we have used has_schema_privilege('anon', 'extensions', 'USAGE') but that
    -- is not appropriate here as it would evaluate true for the extensions schema
    and pe.extnamespace::regnamespace::text = $594)
union all
(
with policies as (
    select
        nsp.nspname as schema_name,
        pb.tablename as table_name,
        polname as policy_name,
        qual,
        with_check
    from
        pg_catalog.pg_policy pa
        join pg_catalog.pg_class pc
            on pa.polrelid = pc.oid
        join pg_catalog.pg_namespace nsp
            on pc.relnamespace = nsp.oid
        join pg_catalog.pg_policies pb
            on pc.relname = pb.tablename
            and nsp.nspname = pb.schemaname
            and pa.polname = pb.policyname
)
select
    $595 as name,
    $596 as title,
    $597 as level,
    $598 as facing,
    array[$599] as categories,
    $600 as description,
    format(
        $601,
        schema_name,
        table_name,
        policy_name
    ) as detail,
    $602 as remediation,
    jsonb_build_object(
        $603, schema_name,
        $604, table_name,
        $605, $606
    ) as metadata,
    format($607, schema_name, table_name, policy_name) as cache_key
from
    policies
where
    schema_name not in (
        $608, $609, $610, $611, $612, $613, $614, $615, $616, $617, $618, $619, $620, $621, $622, $623, $624, $625, $626, $627, $628, $629, $630, $631, $632, $633
    )
    and (
        -- Example: auth.jwt() -> 'user_metadata'
        -- False positives are possible, but it isn't practical to string match
        -- If false positive rate is too high, this expression can iterate
        qual like $634
        or qual like $635
        or with_check like $636
        or with_check like $637
    ))
union all
(
select
    $638 as name,
    $639 as title,
    $640 as level,
    $641 as facing,
    array[$642] as categories,
    $643 as description,
    format(
        $644,
        n.nspname,
        c.relname
    ) as detail,
    $645 as remediation,
    jsonb_build_object(
        $646, n.nspname,
        $647, c.relname,
        $648, $649
    ) as metadata,
    format(
        $650,
        n.nspname,
        c.relname
    ) as cache_key
from
    pg_catalog.pg_class c
    join pg_catalog.pg_namespace n
        on n.oid = c.relnamespace
    left join pg_catalog.pg_depend dep
        on c.oid = dep.objid
        and dep.deptype = $651
where
    c.relkind = $652
    and (
        pg_catalog.has_table_privilege($653, c.oid, $654)
        or pg_catalog.has_table_privilege($655, c.oid, $656)
    )
    and n.nspname = any(array(select trim(unnest(string_to_array(current_setting($657, $658), $659)))))
    and n.nspname not in (
        $660, $661, $662, $663, $664, $665, $666, $667, $668, $669, $670, $671, $672, $673, $674, $675, $676, $677, $678, $679, $680, $681, $682, $683, $684, $685
    )
    and dep.objid is null)
union all
(
select
    $686 as name,
    $687 as title,
    $688 as level,
    $689 as facing,
    array[$690] as categories,
    $691 as description,
    format(
        $692,
        n.nspname,
        c.relname
    ) as detail,
    $693 as remediation,
    jsonb_build_object(
        $694, n.nspname,
        $695, c.relname,
        $696, $697
    ) as metadata,
    format(
        $698,
        n.nspname,
        c.relname
    ) as cache_key
from
    pg_catalog.pg_class c
    join pg_catalog.pg_namespace n
        on n.oid = c.relnamespace
    left join pg_catalog.pg_depend dep
        on c.oid = dep.objid
        and dep.deptype = $699
where
    c.relkind = $700
    and (
        pg_catalog.has_table_privilege($701, c.oid, $702)
        or pg_catalog.has_table_privilege($703, c.oid, $704)
    )
    and n.nspname = any(array(select trim(unnest(string_to_array(current_setting($705, $706), $707)))))
    and n.nspname not in (
        $708, $709, $710, $711, $712, $713, $714, $715, $716, $717, $718, $719, $720, $721, $722, $723, $724, $725, $726, $727, $728, $729, $730, $731, $732, $733
    )
    and dep.objid is null)
union all
(
select
    $734 as name,
    $735 as title,
    $736 as level,
    $737 as facing,
    array[$738] as categories,
    $739 as description,
    format(
        $740,
        n.nspname,
        c.relname,
        a.attname,
        t.typname
    ) as detail,
    $741 as remediation,
    jsonb_build_object(
        $742, n.nspname,
        $743, c.relname,
        $744, a.attname,
        $745, $746
    ) as metadata,
    format(
        $747,
        n.nspname,
        c.relname,
        a.attname
    ) AS cache_key
from
    pg_catalog.pg_attribute a
    join pg_catalog.pg_class c
        on a.attrelid = c.oid
    join pg_catalog.pg_namespace n
        on c.relnamespace = n.oid
    join pg_catalog.pg_type t
        on a.atttypid = t.oid
    join pg_catalog.pg_namespace tn
        on t.typnamespace = tn.oid
where
    tn.nspname = $748
    and t.typname in ($749, $750, $751, $752, $753, $754, $755, $756)
    and n.nspname not in ($757, $758, $759))"
00:00:00.204719,17.8%,5,00:00:00,"with tables as (
SELECT
  c.oid :: int8 AS id,
  nc.nspname AS schema,
  c.relname AS name,
  c.relrowsecurity AS rls_enabled,
  c.relforcerowsecurity AS rls_forced,
  CASE
    WHEN c.relreplident = $1 THEN $2
    WHEN c.relreplident = $3 THEN $4
    WHEN c.relreplident = $5 THEN $6
    ELSE $7
  END AS replica_identity,
  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,
  pg_size_pretty(
    pg_total_relation_size(format($9, nc.nspname, c.relname))
  ) AS size,
  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,
  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,
  obj_description(c.oid) AS comment,
  coalesce(pk.primary_keys, $10) as primary_keys,
  coalesce(
    jsonb_agg(relationships) filter (where relationships is not null),
    $11
  ) as relationships
FROM
  pg_namespace nc
  JOIN pg_class c ON nc.oid = c.relnamespace
  left join (
    select
      c.oid::int8 as table_id,
      jsonb_agg(
        jsonb_build_object(
          $12, c.oid::int8,
          $13, n.nspname,
          $14, c.relname,
          $15, a.attname
        )
        order by array_position(i.indkey, a.attnum)
      ) as primary_keys
    from
      pg_index i
      join pg_class c on i.indrelid = c.oid
      join pg_namespace n on c.relnamespace = n.oid
      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)
    where
      n.nspname IN ($16) AND
      
      i.indisprimary
    group by c.oid
  ) as pk
  on pk.table_id = c.oid
  left join (
    select
      c.oid :: int8 as id,
      c.conname as constraint_name,
      nsa.nspname as source_schema,
      csa.relname as source_table_name,
      sa.attname as source_column_name,
      nta.nspname as target_table_schema,
      cta.relname as target_table_name,
      ta.attname as target_column_name
    from
      pg_constraint c
    join (
      pg_attribute sa
      join pg_class csa on sa.attrelid = csa.oid
      join pg_namespace nsa on csa.relnamespace = nsa.oid
    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)
    join (
      pg_attribute ta
      join pg_class cta on ta.attrelid = cta.oid
      join pg_namespace nta on cta.relnamespace = nta.oid
    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)
    where
      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND
      
      c.contype = $19
  ) as relationships
  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)
  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)
WHERE
  nc.nspname IN ($20) AND
  
  
  c.relkind IN ($21, $22)
  AND NOT pg_is_other_temp_schema(nc.oid)
  AND (
    pg_has_role(c.relowner, $23)
    OR has_table_privilege(
      c.oid,
      $24
    )
    OR has_any_column_privilege(c.oid, $25)
  )
group by
  c.oid,
  c.relname,
  c.relrowsecurity,
  c.relforcerowsecurity,
  c.relreplident,
  nc.nspname,
  pk.primary_keys


)
  , columns as (
-- Adapted from information_schema.columns

SELECT
  c.oid :: int8 AS table_id,
  nc.nspname AS schema,
  c.relname AS table,
  (c.oid || $26 || a.attnum) AS id,
  a.attnum AS ordinal_position,
  a.attname AS name,
  CASE
    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)
    ELSE $27
  END AS default_value,
  CASE
    WHEN t.typtype = $28 THEN CASE
      WHEN bt.typelem <> $29 :: oid
      AND bt.typlen = $30 THEN $31
      WHEN nbt.nspname = $32 THEN format_type(t.typbasetype, $33)
      ELSE $34
    END
    ELSE CASE
      WHEN t.typelem <> $35 :: oid
      AND t.typlen = $36 THEN $37
      WHEN nt.nspname = $38 THEN format_type(a.atttypid, $39)
      ELSE $40
    END
  END AS data_type,
  COALESCE(bt.typname, t.typname) AS format,
  a.attidentity IN ($41, $42) AS is_identity,
  CASE
    a.attidentity
    WHEN $43 THEN $44
    WHEN $45 THEN $46
    ELSE $47
  END AS identity_generation,
  a.attgenerated IN ($48) AS is_generated,
  NOT (
    a.attnotnull
    OR t.typtype = $49 AND t.typnotnull
  ) AS is_nullable,
  (
    c.relkind IN ($50, $51)
    OR c.relkind IN ($52, $53) AND pg_column_is_updatable(c.oid, a.attnum, $54)
  ) AS is_updatable,
  uniques.table_id IS NOT NULL AS is_unique,
  check_constraints.definition AS ""check"",
  array_to_json(
    array(
      SELECT
        enumlabel
      FROM
        pg_catalog.pg_enum enums
      WHERE
        enums.enumtypid = coalesce(bt.oid, t.oid)
        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)
      ORDER BY
        enums.enumsortorder
    )
  ) AS enums,
  col_description(c.oid, a.attnum) AS comment
FROM
  pg_attribute a
  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid
  AND a.attnum = ad.adnum
  JOIN (
    pg_class c
    JOIN pg_namespace nc ON c.relnamespace = nc.oid
  ) ON a.attrelid = c.oid
  JOIN (
    pg_type t
    JOIN pg_namespace nt ON t.typnamespace = nt.oid
  ) ON a.atttypid = t.oid
  LEFT JOIN (
    pg_type bt
    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid
  ) ON t.typtype = $55
  AND t.typbasetype = bt.oid
  LEFT JOIN (
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[$56] AS ordinal_position
    FROM pg_catalog.pg_constraint
    WHERE contype = $57 AND cardinality(conkey) = $58
  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum
  LEFT JOIN (
    -- We only select the first column check
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[$59] AS ordinal_position,
      substring(
        pg_get_constraintdef(pg_constraint.oid, $60),
        $61,
        length(pg_get_constraintdef(pg_constraint.oid, $62)) - $63
      ) AS ""definition""
    FROM pg_constraint
    WHERE contype = $64 AND cardinality(conkey) = $65
    ORDER BY table_id, ordinal_position, oid asc
  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum
WHERE
  nc.nspname IN ($66) AND
  
  
  
  
  NOT pg_is_other_temp_schema(nc.oid)
  AND a.attnum > $67
  AND NOT a.attisdropped
  AND (c.relkind IN ($68, $69, $70, $71, $72))
  AND (
    pg_has_role(c.relowner, $73)
    OR has_column_privilege(
      c.oid,
      a.attnum,
      $74
    )
  )


)
select
  *
  , 
COALESCE(
  (
    SELECT
      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)
    FROM
      columns
  ),
  $75
) AS columns
from tables"
00:00:00.12108,10.6%,5,00:00:00,"SELECT
  pg_t.oid AS id,
  pg_t.tgrelid AS table_id,
  CASE
    WHEN pg_t.tgenabled = $1 THEN $2
    WHEN pg_t.tgenabled = $3 THEN $4
    WHEN pg_t.tgenabled = $5 THEN $6
    WHEN pg_t.tgenabled = $7 THEN $8
    END AS enabled_mode,
  (
    STRING_TO_ARRAY(
      ENCODE(pg_t.tgargs, $9), $10
    )
  )[:pg_t.tgnargs] AS function_args,
  is_t.trigger_name AS name,
  is_t.event_object_table AS table,
  is_t.event_object_schema AS schema,
  is_t.action_condition AS condition,
  is_t.action_orientation AS orientation,
  is_t.action_timing AS activation,
  ARRAY_AGG(is_t.event_manipulation)::text[] AS events,
  pg_p.proname AS function_name,
  pg_n.nspname AS function_schema
FROM
  pg_trigger AS pg_t
JOIN
  pg_class AS pg_c
ON pg_t.tgrelid = pg_c.oid
JOIN pg_namespace AS table_ns
ON pg_c.relnamespace = table_ns.oid
JOIN information_schema.triggers AS is_t
ON is_t.trigger_name = pg_t.tgname
AND pg_c.relname = is_t.event_object_table
AND pg_c.relnamespace = (quote_ident(is_t.event_object_schema))::regnamespace
JOIN pg_proc AS pg_p
ON pg_t.tgfoid = pg_p.oid
JOIN pg_namespace AS pg_n
ON pg_p.pronamespace = pg_n.oid
WHERE
  table_ns.nspname NOT IN ($11,$12,$13)
  
  
  
GROUP BY
  pg_t.oid,
  pg_t.tgrelid,
  pg_t.tgenabled,
  pg_t.tgargs,
  pg_t.tgnargs,
  is_t.trigger_name,
  is_t.event_object_table,
  is_t.event_object_schema,
  is_t.action_condition,
  is_t.action_orientation,
  is_t.action_timing,
  pg_p.proname,
  pg_n.nspname"
00:00:00.095973,8.4%,5,00:00:00,"with base_table_info as ( select c.oid::int8 as id, nc.nspname as schema, c.relname as name, c.relkind, c.relrowsecurity as rls_enabled, c.relforcerowsecurity as rls_forced, c.relreplident, c.relowner, obj_description(c.oid) as comment from pg_class c join pg_namespace nc on nc.oid = c.relnamespace where c.oid = $1 and not pg_is_other_temp_schema(nc.oid) and ( pg_has_role(c.relowner, $2) or has_table_privilege( c.oid, $3 ) or has_any_column_privilege(c.oid, $4) ) ), table_stats as ( select b.id, case when b.relreplident = $5 then $6 when b.relreplident = $7 then $8 when b.relreplident = $9 then $10 else $11 end as replica_identity, pg_total_relation_size(format($12, b.schema, b.name))::int8 as bytes, pg_size_pretty(pg_total_relation_size(format($13, b.schema, b.name))) as size, pg_stat_get_live_tuples(b.id) as live_rows_estimate, pg_stat_get_dead_tuples(b.id) as dead_rows_estimate from base_table_info b where b.relkind in ($14, $15) ), primary_keys as ( select i.indrelid as table_id, jsonb_agg(jsonb_build_object( $16, n.nspname, $17, c.relname, $18, i.indrelid::int8, $19, a.attname )) as primary_keys from pg_index i join pg_class c on i.indrelid = c.oid join pg_attribute a on (a.attrelid = c.oid and a.attnum = any(i.indkey)) join pg_namespace n on c.relnamespace = n.oid where i.indisprimary group by i.indrelid ), relationships as ( select c.conrelid as source_id, c.confrelid as target_id, jsonb_build_object( $20, c.oid::int8, $21, c.conname, $22, c.confdeltype, $23, c.confupdtype, $24, nsa.nspname, $25, csa.relname, $26, sa.attname, $27, nta.nspname, $28, cta.relname, $29, ta.attname ) as rel_info from pg_constraint c join pg_class csa on c.conrelid = csa.oid join pg_namespace nsa on csa.relnamespace = nsa.oid join pg_attribute sa on (sa.attrelid = c.conrelid and sa.attnum = any(c.conkey)) join pg_class cta on c.confrelid = cta.oid join pg_namespace nta on cta.relnamespace = nta.oid join pg_attribute ta on (ta.attrelid = c.confrelid and ta.attnum = any(c.confkey)) where c.contype = $30 ), columns as ( select a.attrelid as table_id, jsonb_agg(jsonb_build_object( $31, (a.attrelid || $32 || a.attnum), $33, c.oid::int8, $34, nc.nspname, $35, c.relname, $36, a.attnum, $37, a.attname, $38, case when a.atthasdef then pg_get_expr(ad.adbin, ad.adrelid) else $39 end, $40, case when t.typtype = $41 then case when bt.typelem <> $42::oid and bt.typlen = $43 then $44 when nbt.nspname = $45 then format_type(t.typbasetype, $46) else $47 end else case when t.typelem <> $48::oid and t.typlen = $49 then $50 when nt.nspname = $51 then format_type(a.atttypid, $52) else $53 end end, $54, case when t.typtype = $55 then case when nt.nspname <> $56 then concat(nt.nspname, $57, coalesce(bt.typname, t.typname)) else coalesce(bt.typname, t.typname) end else coalesce(bt.typname, t.typname) end, $58, a.attidentity in ($59, $60), $61, case a.attidentity when $62 then $63 when $64 then $65 else $66 end, $67, a.attgenerated in ($68), $69, not (a.attnotnull or t.typtype = $70 and t.typnotnull), $71, ( b.relkind in ($72, $73) or (b.relkind in ($74, $75) and pg_column_is_updatable(b.id, a.attnum, $76)) ), $77, uniques.table_id is not null, $78, check_constraints.definition, $79, col_description(c.oid, a.attnum), $80, coalesce( ( select jsonb_agg(e.enumlabel order by e.enumsortorder) from pg_catalog.pg_enum e where e.enumtypid = coalesce(bt.oid, t.oid) or e.enumtypid = coalesce(bt.typelem, t.typelem) ), $81::jsonb ) ) order by a.attnum) as columns from pg_attribute a join base_table_info b on a.attrelid = b.id join pg_class c on a.attrelid = c.oid join pg_namespace nc on c.relnamespace = nc.oid left join pg_attrdef ad on (a.attrelid = ad.adrelid and a.attnum = ad.adnum) join pg_type t on a.atttypid = t.oid join pg_namespace nt on t.typnamespace = nt.oid left join pg_type bt on (t.typtype = $82 and t.typbasetype = bt.oid) left join pg_namespace nbt on bt.typnamespace = nbt.oid left join ( select conrelid as table_id, conkey[$83] as ordinal_position from pg_catalog.pg_constraint where contype = $84 and cardinality(conkey) = $85 group by conrelid, conkey[1] ) as uniques on uniques.table_id = a.attrelid and uniques.ordinal_position = a.attnum left join ( select distinct on (conrelid, conkey[1]) conrelid as table_id, conkey[$86] as ordinal_position, substring( pg_get_constraintdef(oid, $87), $88, length(pg_get_constraintdef(oid, $89)) - $90 ) as definition from pg_constraint where contype = $91 and cardinality(conkey) = $92 order by conrelid, conkey[1], oid asc ) as check_constraints on check_constraints.table_id = a.attrelid and check_constraints.ordinal_position = a.attnum where a.attnum > $93 and not a.attisdropped group by a.attrelid ) select case b.relkind when $94 then jsonb_build_object( $95, b.relkind, $96, b.id, $97, b.schema, $98, b.name, $99, b.rls_enabled, $100, b.rls_forced, $101, ts.replica_identity, $102, ts.bytes, $103, ts.size, $104, ts.live_rows_estimate, $105, ts.dead_rows_estimate, $106, b.comment, $107, coalesce(pk.primary_keys, $108::jsonb), $109, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $110::jsonb ), $111, coalesce(c.columns, $112::jsonb) ) when $113 then jsonb_build_object( $114, b.relkind, $115, b.id, $116, b.schema, $117, b.name, $118, b.rls_enabled, $119, b.rls_forced, $120, ts.replica_identity, $121, ts.bytes, $122, ts.size, $123, ts.live_rows_estimate, $124, ts.dead_rows_estimate, $125, b.comment, $126, coalesce(pk.primary_keys, $127::jsonb), $128, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $129::jsonb ), $130, coalesce(c.columns, $131::jsonb) ) when $132 then jsonb_build_object( $133, b.relkind, $134, b.id, $135, b.schema, $136, b.name, $137, (pg_relation_is_updatable(b.id, $138) & $139) = $140, $141, b.comment, $142, coalesce(c.columns, $143::jsonb) ) when $144 then jsonb_build_object( $145, b.relkind, $146, b.id, $147, b.schema, $148, b.name, $149, $150, $151, b.comment, $152, coalesce(c.columns, $153::jsonb) ) when $154 then jsonb_build_object( $155, b.relkind, $156, b.id, $157, b.schema, $158, b.name, $159, b.comment, $160, coalesce(c.columns, $161::jsonb) ) end as entity from base_table_info b left join table_stats ts on b.id = ts.id left join primary_keys pk on b.id = pk.table_id left join columns c on b.id = c.table_id"
00:00:00.047076,4.1%,1,00:00:00,"SELECT
  (interval $1 * total_exec_time)::text AS total_exec_time,
  to_char((total_exec_time/sum(total_exec_time) OVER()) * $2, $3) || $4  AS prop_exec_time,
  to_char(calls, $5) AS ncalls,
  /*
    Handle column names for 15 and 17
  */
  (
    interval $6 * (
      COALESCE(
        (to_jsonb(s) ->> $7)::double precision,
        (to_jsonb(s) ->> $8)::double precision,
        $9
      )
      +
      COALESCE(
        (to_jsonb(s) ->> $10)::double precision,
        (to_jsonb(s) ->> $11)::double precision,
        $12
      )
    )
  )::text AS sync_io_time,
  query
FROM pg_stat_statements s WHERE userid = (SELECT usesysid FROM pg_user WHERE usename = current_user LIMIT $13)
ORDER BY total_exec_time DESC
LIMIT $14"
00:00:00.035641,3.1%,2,00:00:00,"-- Ref: https://github.com/okbob/plpgsql_check#mass-check
SELECT p.proname, plpgsql_check_function(p.oid, format:=$2)
FROM pg_catalog.pg_namespace n
JOIN pg_catalog.pg_proc p ON pronamespace = n.oid
JOIN pg_catalog.pg_language l ON p.prolang = l.oid
WHERE l.lanname = $3 AND p.prorettype <> $4 AND n.nspname = $1::text"
00:00:00.027758,2.4%,1,00:00:00,"WITH constants AS (
  SELECT current_setting($2)::numeric AS bs, $3 AS hdr, $4 AS ma
), bloat_info AS (
  SELECT
    ma,bs,schemaname,tablename,
    (datawidth+(hdr+ma-(case when hdr%ma=$5 THEN ma ELSE hdr%ma END)))::numeric AS datahdr,
    (maxfracsum*(nullhdr+ma-(case when nullhdr%ma=$6 THEN ma ELSE nullhdr%ma END))) AS nullhdr2
  FROM (
    SELECT
      schemaname, tablename, hdr, ma, bs,
      SUM(($7-null_frac)*avg_width) AS datawidth,
      MAX(null_frac) AS maxfracsum,
      hdr+(
        SELECT $8+count(*)/$9
        FROM pg_stats s2
        WHERE null_frac<>$10 AND s2.schemaname = s.schemaname AND s2.tablename = s.tablename
      ) AS nullhdr
    FROM pg_stats s, constants
    GROUP BY 1,2,3,4,5
  ) AS foo
), table_bloat AS (
  SELECT
    schemaname, tablename, cc.relpages, bs,
    CEIL((cc.reltuples*((datahdr+ma-
      (CASE WHEN datahdr%ma=$11 THEN ma ELSE datahdr%ma END))+nullhdr2+$12))/(bs-$13::float)) AS otta
  FROM bloat_info
  JOIN pg_class cc ON cc.relname = bloat_info.tablename
  JOIN pg_namespace nn ON cc.relnamespace = nn.oid AND nn.nspname = bloat_info.schemaname
  WHERE NOT nn.nspname LIKE ANY($1)
), index_bloat AS (
  SELECT
    schemaname, tablename, bs,
    COALESCE(c2.relname,$14) AS iname, COALESCE(c2.reltuples,$15) AS ituples, COALESCE(c2.relpages,$16) AS ipages,
    COALESCE(CEIL((c2.reltuples*(datahdr-$17))/(bs-$18::float)),$19) AS iotta -- very rough approximation, assumes all cols
  FROM bloat_info
  JOIN pg_class cc ON cc.relname = bloat_info.tablename
  JOIN pg_namespace nn ON cc.relnamespace = nn.oid AND nn.nspname = bloat_info.schemaname
  JOIN pg_index i ON indrelid = cc.oid
  JOIN pg_class c2 ON c2.oid = i.indexrelid
  WHERE NOT nn.nspname LIKE ANY($1)
), bloat_summary AS (
  SELECT
    $20 as type,
    FORMAT($21, schemaname, tablename) AS name,
    ROUND(CASE WHEN otta=$22 THEN $23 ELSE table_bloat.relpages/otta::numeric END,$24) AS bloat,
    CASE WHEN relpages < otta THEN $25 ELSE (bs*(table_bloat.relpages-otta)::bigint)::bigint END AS raw_waste
  FROM table_bloat
    UNION
  SELECT
    $26 as type,
    FORMAT($27, schemaname, tablename, iname) AS name,
    ROUND(CASE WHEN iotta=$28 OR ipages=$29 THEN $30 ELSE ipages/iotta::numeric END,$31) AS bloat,
  CASE WHEN ipages < iotta THEN $32 ELSE (bs*(ipages-iotta))::bigint END AS raw_waste
  FROM index_bloat
)
SELECT type, name, bloat, pg_size_pretty(raw_waste) as waste
FROM bloat_summary
ORDER BY raw_waste DESC, bloat DESC"
00:00:00.023206,2.0%,5,00:00:00,"SELECT
  pol.oid :: int8 AS id,
  n.nspname AS schema,
  c.relname AS table,
  c.oid :: int8 AS table_id,
  pol.polname AS name,
  CASE
    WHEN pol.polpermissive THEN $1 :: text
    ELSE $2 :: text
  END AS action,
  CASE
    WHEN pol.polroles = $3 :: oid [] THEN array_to_json(
      string_to_array($4 :: text, $5 :: text) :: name []
    )
    ELSE array_to_json(
      ARRAY(
        SELECT
          pg_roles.rolname
        FROM
          pg_roles
        WHERE
          pg_roles.oid = ANY (pol.polroles)
        ORDER BY
          pg_roles.rolname
      )
    )
  END AS roles,
  CASE
    pol.polcmd
    WHEN $6 :: ""char"" THEN $7 :: text
    WHEN $8 :: ""char"" THEN $9 :: text
    WHEN $10 :: ""char"" THEN $11 :: text
    WHEN $12 :: ""char"" THEN $13 :: text
    WHEN $14 :: ""char"" THEN $15 :: text
    ELSE $16 :: text
  END AS command,
  pg_get_expr(pol.polqual, pol.polrelid) AS definition,
  pg_get_expr(pol.polwithcheck, pol.polrelid) AS check
FROM
  pg_policy pol
  JOIN pg_class c ON c.oid = pol.polrelid
  LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE
  n.nspname NOT IN ($17,$18,$19)"
00:00:00.020251,1.8%,1,00:00:00,"COPY (WITH constants AS (
  SELECT current_setting('block_size')::numeric AS bs, 23 AS hdr, 4 AS ma
), bloat_info AS (
  SELECT
    ma,bs,schemaname,tablename,
    (datawidth+(hdr+ma-(case when hdr%ma=0 THEN ma ELSE hdr%ma END)))::numeric AS datahdr,
    (maxfracsum*(nullhdr+ma-(case when nullhdr%ma=0 THEN ma ELSE nullhdr%ma END))) AS nullhdr2
  FROM (
    SELECT
      schemaname, tablename, hdr, ma, bs,
      SUM((1-null_frac)*avg_width) AS datawidth,
      MAX(null_frac) AS maxfracsum,
      hdr+(
        SELECT 1+count(*)/8
        FROM pg_stats s2
        WHERE null_frac<>0 AND s2.schemaname = s.schemaname AND s2.tablename = s.tablename
      ) AS nullhdr
    FROM pg_stats s, constants
    GROUP BY 1,2,3,4,5
  ) AS foo
), table_bloat AS (
  SELECT
    schemaname, tablename, cc.relpages, bs,
    CEIL((cc.reltuples*((datahdr+ma-
      (CASE WHEN datahdr%ma=0 THEN ma ELSE datahdr%ma END))+nullhdr2+4))/(bs-20::float)) AS otta
  FROM bloat_info
  JOIN pg_class cc ON cc.relname = bloat_info.tablename
  JOIN pg_namespace nn ON cc.relnamespace = nn.oid AND nn.nspname = bloat_info.schemaname
  WHERE NOT nn.nspname LIKE ANY('{information\_schema,pg\_%,\_analytics,\_realtime,\_supavisor,auth,extensions,pgbouncer,realtime,storage,supabase\_functions,supabase\_migrations,cron,dbdev,graphql,graphql\_public,net,pgmq,pgsodium,pgsodium\_masks,pgtle,repack,tiger,tiger\_data,timescaledb\_%,\_timescaledb\_%,topology,vault}'::text[])
), index_bloat AS (
  SELECT
    schemaname, tablename, bs,
    COALESCE(c2.relname,'?') AS iname, COALESCE(c2.reltuples,0) AS ituples, COALESCE(c2.relpages,0) AS ipages,
    COALESCE(CEIL((c2.reltuples*(datahdr-12))/(bs-20::float)),0) AS iotta -- very rough approximation, assumes all cols
  FROM bloat_info
  JOIN pg_class cc ON cc.relname = bloat_info.tablename
  JOIN pg_namespace nn ON cc.relnamespace = nn.oid AND nn.nspname = bloat_info.schemaname
  JOIN pg_index i ON indrelid = cc.oid
  JOIN pg_class c2 ON c2.oid = i.indexrelid
  WHERE NOT nn.nspname LIKE ANY('{information\_schema,pg\_%,\_analytics,\_realtime,\_supavisor,auth,extensions,pgbouncer,realtime,storage,supabase\_functions,supabase\_migrations,cron,dbdev,graphql,graphql\_public,net,pgmq,pgsodium,pgsodium\_masks,pgtle,repack,tiger,tiger\_data,timescaledb\_%,\_timescaledb\_%,topology,vault}'::text[])
), bloat_summary AS (
  SELECT
    'table' as type,
    FORMAT('%I.%I', schemaname, tablename) AS name,
    ROUND(CASE WHEN otta=0 THEN 0.0 ELSE table_bloat.relpages/otta::numeric END,1) AS bloat,
    CASE WHEN relpages < otta THEN '0' ELSE (bs*(table_bloat.relpages-otta)::bigint)::bigint END AS raw_waste
  FROM table_bloat
    UNION
  SELECT
    'index' as type,
    FORMAT('%I.%I::%I', schemaname, tablename, iname) AS name,
    ROUND(CASE WHEN iotta=0 OR ipages=0 THEN 0.0 ELSE ipages/iotta::numeric END,1) AS bloat,
  CASE WHEN ipages < iotta THEN '0' ELSE (bs*(ipages-iotta))::bigint END AS raw_waste
  FROM index_bloat
)
SELECT type, name, bloat, pg_size_pretty(raw_waste) as waste
FROM bloat_summary
ORDER BY raw_waste DESC, bloat DESC
) TO STDOUT WITH CSV HEADER"
00:00:00.019531,1.7%,2,00:00:00,"SELECT
  ts.name,
  pg_size_pretty(ts.table_size_bytes) AS table_size,
  pg_size_pretty(ts.index_size_bytes) AS index_size,
  pg_size_pretty(ts.total_size_bytes) AS total_size,
  COALESCE(rc.estimated_row_count, $2) AS estimated_row_count,
  COALESCE(rc.seq_scans, $3) AS seq_scans
FROM (
  SELECT
    FORMAT($4, n.nspname, c.relname) AS name,
    pg_table_size(c.oid) AS table_size_bytes,
    pg_indexes_size(c.oid) AS index_size_bytes,
    pg_total_relation_size(c.oid) AS total_size_bytes
  FROM pg_class c
  LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
  WHERE NOT n.nspname LIKE ANY($1)
    AND c.relkind = $5
) ts
LEFT JOIN (
  SELECT
    FORMAT($6, schemaname, relname) AS name,
    n_live_tup AS estimated_row_count,
    seq_scan AS seq_scans
  FROM pg_stat_user_tables
  WHERE NOT schemaname LIKE ANY($1)
) rc ON rc.name = ts.name
ORDER BY ts.total_size_bytes DESC"
