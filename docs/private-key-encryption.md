# Private Key Encryption (Server-Side Transactions)

## Overview
This document describes a practical approach to storing an encrypted private key in environment variables, decrypting it only on the server, and using it for backend transactions. It also covers recommended security practices and longer-term improvements.

The goal is:
- Store only encrypted private key material in env vars.
- Keep the decryption key separate from the ciphertext.
- Decrypt only on the server and only when needed.

## Threat Model (What This Protects Against)
- Accidental exposure of `.env` contents.
- Leakage of encrypted values in logs or error traces.
- Compromise of one secret store without the other.

## What It Does Not Protect Against
- Full server compromise (attacker can read memory or decrypt at runtime).
- Code execution vulnerabilities that allow access to runtime secrets.

## Recommended Implementation (AES-256-GCM)
Use authenticated encryption (AES-256-GCM) with a 32-byte master key.

### 1) Generate a Master Key
Generate a 32-byte random key and store it in a secure secret manager.

Example (local only):
```
node -e "console.log(require('crypto').randomBytes(32).toString('base64'))"
```

Store this as `PRIVATE_KEY_MASTER_KEY` in your secrets manager.

### 2) Encrypt the Private Key (One-Time)
Create a script to generate the encrypted payload.

Example script (`scripts/encrypt-private-key.js`):
```
const crypto = require('crypto');

const masterKey = process.env.PRIVATE_KEY_MASTER_KEY; // base64
const privateKey = process.env.PRIVATE_KEY; // 0x...

if (!masterKey || !privateKey) {
  throw new Error('PRIVATE_KEY_MASTER_KEY and PRIVATE_KEY required');
}

const key = Buffer.from(masterKey, 'base64');
if (key.length !== 32) throw new Error('Master key must be 32 bytes (base64)');

const iv = crypto.randomBytes(12);
const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);
const ciphertext = Buffer.concat([cipher.update(privateKey, 'utf8'), cipher.final()]);
const tag = cipher.getAuthTag();

const payload = [
  iv.toString('base64'),
  tag.toString('base64'),
  ciphertext.toString('base64'),
].join(':');

console.log(payload);
```

Run it in a secure environment:
```
PRIVATE_KEY_MASTER_KEY=... PRIVATE_KEY=0x... node scripts/encrypt-private-key.js
```

Store output as `ENCRYPTED_PRIVATE_KEY` in your env.

### 3) Decrypt at Runtime (Server-Only)
Create a server utility to decrypt when needed.

Example (`lib/crypto/decryptPrivateKey.ts`):
```
import crypto from 'crypto';

export function decryptPrivateKey(): string {
  const encrypted = process.env.ENCRYPTED_PRIVATE_KEY;
  const masterKey = process.env.PRIVATE_KEY_MASTER_KEY;

  if (!encrypted || !masterKey) {
    throw new Error('Missing ENCRYPTED_PRIVATE_KEY or PRIVATE_KEY_MASTER_KEY');
  }

  const [ivB64, tagB64, dataB64] = encrypted.split(':');
  const key = Buffer.from(masterKey, 'base64');
  const iv = Buffer.from(ivB64, 'base64');
  const tag = Buffer.from(tagB64, 'base64');
  const data = Buffer.from(dataB64, 'base64');

  const decipher = crypto.createDecipheriv('aes-256-gcm', key, iv);
  decipher.setAuthTag(tag);

  const plaintext = Buffer.concat([decipher.update(data), decipher.final()]);
  return plaintext.toString('utf8');
}
```

Usage (server only):
```
import { Wallet } from 'ethers';
import { decryptPrivateKey } from 'lib/crypto/decryptPrivateKey';

const signer = new Wallet(decryptPrivateKey(), provider);
```

## Deployment & Secrets Storage
- Store `ENCRYPTED_PRIVATE_KEY` in your app env (safe-ish).
- Store `PRIVATE_KEY_MASTER_KEY` in a separate secret store.
- Rotate the master key by re-encrypting the private key.

## Operational Guidance
- Never log the decrypted key or intermediate values.
- Instantiate signer once at server start when possible.
- Use different keys for staging vs production.
- Ensure server-only boundaries (no bundling into client).

## Recommendations (Immediate/Short Term)
- Add strict runtime checks so the app fails to start if secrets are missing.
- Store secrets only in platform secret storage (not in `.env` on production).
- Add health checks or audits to confirm no plaintext key is ever written.

## Improvements (Medium to Long Term, Out of Scope)
These are not required now but are recommended for higher assurance:

1) Hardware-backed signing (KMS/HSM)
- Use AWS KMS, GCP KMS, or Azure Key Vault to sign without exposing the key to the app.
- Replace direct `Wallet` usage with a KMS-backed signer (custom or library-based).

2) Split-key / Envelope encryption
- Encrypt the private key with a data key generated by KMS.
- Store encrypted data key + ciphertext in env.
- Decrypt data key via KMS at runtime.

3) Vault-based secret delivery
- Use HashiCorp Vault or cloud-native secret rotation.
- Configure short-lived access tokens for app to fetch secrets.

4) Transaction policy enforcement
- Use a policy engine that validates parameters before signing.
- Example: allowlisted contracts, max transfer amounts, daily limits.

5) Audit logging and anomaly detection
- Log transaction intent and results to a secure audit sink.
- Alert on unexpected destinations or high-value calls.

6) Multi-sig or MPC
- For high-value operations, require multiple approvals or MPC signing.

7) Separate signing microservice
- A dedicated signer service with its own strict network policy and firewall.
- Reduces blast radius of main app compromise.

## Summary
This approach gives a practical baseline: encrypted env values + server-side decryption. It is suitable for most production deployments when paired with a strong secret manager and secure server practices. For higher security needs, move to KMS-backed signing or multi-sig workflows.
